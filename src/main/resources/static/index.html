<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Curl Parser - Multi-API Testing</title>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .tab:hover {
            color: #667eea;
            background: #f8f9ff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        textarea { 
            width: 100%; 
            height: 200px; 
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .multi-curl-textarea {
            height: 300px;
        }
        
        .execution-options {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .execution-options h3 {
            margin: 0 0 15px 0;
            color: #333;
        }
        
        .radio-group {
            display: flex;
            gap: 20px;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .radio-option input[type="radio"] {
            margin: 0;
        }
        
        .radio-option label {
            cursor: pointer;
            font-weight: 500;
        }
        
        button { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled { 
            background: #ccc; 
            cursor: not-allowed; 
            transform: none;
            box-shadow: none;
        }
        
        .warning { 
            color: #e74c3c; 
            background: #fdf2f2;
            padding: 10px 15px;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
            margin: 15px 0;
        }
        
        .info {
            color: #3498db;
            background: #f0f8ff;
            padding: 10px 15px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            margin: 15px 0;
        }

        .section-header {
          cursor: pointer;
          background: #f8f9ff;
          padding: 15px;
          margin-top: 10px;
          font-weight: 600;
          display: flex;
          align-items: center;
          border-radius: 8px;
          border: 1px solid #e0e0e0;
          transition: all 0.3s ease;
        }
        
        .section-header:hover {
            background: #f0f4ff;
        }

        .arrow {
          display: inline-block;
          transition: transform 0.2s ease;
          margin-right: 12px;
          font-size: 18px;
        }

        .arrow.collapsed { transform: rotate(0deg); }
        .arrow.expanded { transform: rotate(90deg); }

        .section-body {
          display: none;
          white-space: pre-wrap;
          padding: 15px;
          border-left: 3px solid #667eea;
          margin-bottom: 10px;
          background: #fff;
          border-radius: 0 0 8px 8px;
          font-family: 'Courier New', monospace;
          font-size: 13px;
        }

        /* üîÑ Loader Styles */
        #loader {
          display: none;
          margin-top: 20px;
          text-align: center;
          padding: 30px;
        }
        .spinner {
          border: 4px solid #f3f3f3;
          border-top: 4px solid #667eea;
          border-radius: 50%;
          width: 40px;
          height: 40px;
          animation: spin 1s linear infinite;
          margin: 0 auto 15px;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 2em;
        }
        
        .stat-card p {
            margin: 0;
            opacity: 0.9;
        }
        
        #logs { 
            background: #f8f9fa; 
            padding: 20px; 
            min-height: 400px; 
            border: 1px solid #e0e0e0; 
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .result-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.3s ease;
            border-left: 5px solid #e0e0e0;
        }
        
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .result-card.success {
            border-left-color: #10b981;
        }
        
        .result-card.error {
            border-left-color: #ef4444;
        }
        
        .result-card.warning {
            border-left-color: #f59e0b;
        }
        
        .result-card.info {
            border-left-color: #3b82f6;
        }
        
        .card-header {
            padding: 20px;
            border-bottom: 1px solid #f1f5f9;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .card-title {
            font-weight: 600;
            font-size: 16px;
            color: #1f2937;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-badge.success {
            background: #d1fae5;
            color: #065f46;
        }
        
        .status-badge.error {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .status-badge.warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        .status-badge.info {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .card-body {
            padding: 20px;
        }
        
        .test-summary {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .summary-item {
            text-align: center;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
        }
        
        .summary-item h4 {
            margin: 0 0 5px 0;
            font-size: 18px;
            font-weight: 700;
        }
        
        .summary-item p {
            margin: 0;
            font-size: 12px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .summary-item.passed h4 {
            color: #10b981;
        }
        
        .summary-item.failed h4 {
            color: #ef4444;
        }
        
        .summary-item.skipped h4 {
            color: #f59e0b;
        }
        
        .test-details {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .test-details h5 {
            margin: 0 0 10px 0;
            color: #374151;
            font-size: 14px;
            font-weight: 600;
        }
        
        .test-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .test-item {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .test-item.passed {
            background: #d1fae5;
            color: #065f46;
        }
        
        .test-item.failed {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
            font-weight: 600;
        }
        
        .test-item.skipped {
            background: #fef3c7;
            color: #92400e;
        }
        
        .test-item.running {
            background: #e0e7ff;
            color: #3730a3;
        }
        
        .expand-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .expand-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }
        
        .detailed-results {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e5e7eb;
        }
        
        .detailed-results.show {
            display: block;
        }
        
        .api-info {
            background: #f1f5f9;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #475569;
        }
        
        .execution-time {
            font-size: 12px;
            color: #6b7280;
            margin-top: 10px;
        }
        
        .test-block {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .test-block-header {
            background: #f1f5f9;
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .test-block-header h6 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .test-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .test-status.passed {
            background: #d1fae5;
            color: #065f46;
        }
        
        .test-status.failed {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .test-status.skipped {
            background: #fef3c7;
            color: #92400e;
        }
        
        .test-status.running {
            background: #e0e7ff;
            color: #3730a3;
        }
        
        .test-block-details {
            padding: 15px;
        }
        
        .detail-line {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #475569;
            margin-bottom: 8px;
            line-height: 1.4;
            background: white;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #e2e8f0;
        }
        
        .detail-line:last-child {
            margin-bottom: 0;
        }

        /* Request/Response Detail Boxes */
        .request-details, .response-details {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin: 15px 0;
            overflow: hidden;
        }

        .request-details {
            border-left: 4px solid #3b82f6;
        }

        .response-details {
            border-left: 4px solid #10b981;
        }

        .test-content {
            border-left: 4px solid #f59e0b;
        }

        .test-content .detail-box-content {
            max-height: 800px;
            overflow-y: auto;
            background: #fafafa;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
        }

        .content-length {
            font-size: 11px;
            color: #6b7280;
            font-weight: normal;
            margin-left: 8px;
        }

        .detail-box-header {
            background: #f1f5f9;
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 600;
            font-size: 14px;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .detail-box-content {
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            color: #475569;
            white-space: pre-wrap;
            max-height: 600px;
            overflow-y: auto;
            word-wrap: break-word;
            word-break: break-all;
        }
        
        .detail-box-content:first-line {
            margin-top: 0;
        }

        .status-code {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .status-code.success {
            background: #d1fae5;
            color: #065f46;
        }

        .status-code.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-code.warning {
            background: #fef3c7;
            color: #92400e;
        }

        .status-code.info {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .curl-preview {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            margin: 15px 0;
            overflow-x: auto;
        }

        /* Container for expected results */
        .expected-response {
          border: 1px solid #90caf9; /* light blue border */
          border-radius: 6px;
          background-color: #e3f2fd; /* light blue background */
          margin: 12px 0; /* reduce vertical spacing */
          padding: 8px; /* reduced padding */
        }

        /* Header for the section */
        .expected-response-header {
          background-color: #2196f3; /* blue header */
          color: #fff;
          font-weight: 600;
          font-size: 13px; /* slightly smaller */
          padding: 4px 8px; /* smaller padding */
          border-radius: 4px 4px 0 0;
          display: flex;
          align-items: center;
          gap: 4px;
        }

        /* Container for all items */
        .expected-response-content {
          display: flex;
          flex-direction: column;
          gap: 4px; /* smaller gap between items */
          padding: 4px 8px; /* reduce inner padding */
        }

        /* Each expected result item */
        .expected-response-item {
          background-color: #f5f5f5;
          border: 1px solid #cfd8dc;
          border-radius: 4px;
          padding: 4px 6px; /* smaller padding */
          display: flex;
          flex-wrap: wrap;
          align-items: baseline;
          gap: 4px;
          font-size: 12px; /* smaller font for compactness */
        }

        /* Label */
        .expected-response-label {
          font-weight: 500;
          min-width: 150px;
          color: #333;
        }

        /* Value */
        .expected-response-value {
          color: #222;
          font-size: 12px;
          line-height: 1.3;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>üöÄ API Testing Suite</h1>
        <p>Test multiple APIs with comprehensive automated testing.</p>
    </div>
    
    <div class="content">
        <p class="info">üí° You can paste multiple cURL commands separated by line breaks.</p>
        
        <textarea id="multiCurlInput" class="multi-curl-textarea" placeholder="Enter multiple cURL commands here (one per line or separated by line breaks)..."></textarea>
        
        <br><br>
        <button id="executeMultiBtn" disabled>Execute Multiple APIs</button>

        <!-- üîÑ Loader element -->
        <div id="loader">
            <div class="spinner"></div>
            <p>Executing tests, please wait...</p>
        </div>

        <h2>üìä Results</h2>
        <div id="logs"></div>
<script>
    const multiCurlInput = document.getElementById("multiCurlInput");
    const executeMultiBtn = document.getElementById("executeMultiBtn");
    const logs = document.getElementById("logs");
    const loader = document.getElementById("loader");

    // Expected Results Mapping
    const EXPECTED_RESULTS_MAP = {
      SMOKE: [
        { icon: '‚úÖ', label: 'Basic Smoke Test', expected: 'API should return 200 (Success)' }
      ],
      INVALID_PAYLOAD: [
        { icon: '‚ùå', label: 'Invalid Payload Body', expected: 'API should return 400 or 422 (Bad Request / Unprocessable Entity)' }
      ],
      MISSING_HEADERS: [
        { icon: '‚ùå', label: 'Missing Headers', expected: 'API should return 400 or 401 (Bad Request / Unauthorized)' }
      ],
      MISSING_AUTH: [
        { icon: '‚ùå', label: 'Missing Authentication', expected: 'API should return 401 or 403 (Unauthorized / Forbidden)' }
      ],
      UNSUPPORTED_METHOD: [
        { icon: '‚ùå', label: 'Unsupported HTTP Method', expected: 'API should return 405 (Method Not Allowed)' }
      ],
      MISSING_BODY: [
        { icon: '‚ùå', label: 'Missing Request Body', expected: 'API should return 400 or 422 (Bad Request / Unprocessable Entity)' }
      ],
      INVALID_PATH: [
        { icon: '‚ùå', label: 'Invalid Path Parameters', expected: 'API should return 404 (Not Found)' }
      ],
      INVALID_QUERY: [
        { icon: '‚ùå', label: 'Invalid Query Parameters', expected: 'API should return 400 or 422 (Bad Request / Unprocessable Entity)' }
      ],
      MISSING_QUERY: [
        { icon: '‚ùå', label: 'Missing Query Parameters', expected: 'API should return 400 or 422 (Bad Request / Unprocessable Entity)' }
      ],
      WRONG_CONTENT_TYPE: [
        { icon: '‚ùå', label: 'Wrong Content-Type', expected: 'API should return 400 or 415 (Bad Request / Unsupported Media Type)' }
      ],
      MALFORMED_JSON: [
        { icon: '‚ùå', label: 'Malformed JSON', expected: 'API should return 400 or 422 (Bad Request / Unprocessable Entity)' }
      ],
      OVERSIZED_PAYLOAD: [
        { icon: '‚ùå', label: 'Oversized Payload', expected: 'API should return 413 or 400 (Payload Too Large / Bad Request)' }
      ],
      SQL_INJECTION: [
        { icon: 'üîí', label: 'SQL Injection', expected: 'API should return 400 or 422 (Bad Request / Unprocessable Entity)' }
      ],
      SPECIAL_CHAR: [
        { icon: 'üî§', label: 'Special Characters', expected: 'API should return 200 or 400 (Success or Bad Request)' }
      ],
      EMPTY_VALUES: [
        { icon: 'üìù', label: 'Empty Values', expected: 'API should return 400 or 422 (Bad Request / Unprocessable Entity)' }
      ]
    };

    const TEST_CASE_EXPECTED_KEYS = {
      'Smoke Test': ['SMOKE'],
      'Invalid Payload Test': ['INVALID_PAYLOAD'],
      'Missing Headers Test': ['MISSING_HEADERS'],
      'Missing Auth Test': ['MISSING_AUTH'],
      'Unsupported Method Test': ['UNSUPPORTED_METHOD'],
      'Missing Body Test': ['MISSING_BODY'],
      'Invalid Path Test': ['INVALID_PATH'],
      'Invalid Query Test': ['INVALID_QUERY'],
      'Missing Query Test': ['MISSING_QUERY'],
      'Wrong Content-Type Test': ['WRONG_CONTENT_TYPE'],
      'Malformed JSON Test': ['MALFORMED_JSON'],
      'Oversized Payload Test': ['OVERSIZED_PAYLOAD'],
      'SQL Injection Test': ['SQL_INJECTION'],
      'Special Characters Test': ['SPECIAL_CHAR'],
      'Empty Values Test': ['EMPTY_VALUES']
    };

    // Function to get relevant expected results for a test case
    function getRelevantExpectedResults(testName) {
      // Extract the test type from the test name
      let testType = '';
      
      if (testName.includes('Basic Smoke Test')) {
        testType = 'Smoke Test';
      } else if (testName.includes('Invalid Payload Body')) {
        testType = 'Invalid Payload Test';
      } else if (testName.includes('Missing Headers')) {
        testType = 'Missing Headers Test';
      } else if (testName.includes('Missing Authentication')) {
        testType = 'Missing Auth Test';
      } else if (testName.includes('Unsupported HTTP Method')) {
        testType = 'Unsupported Method Test';
      } else if (testName.includes('Missing Request Body')) {
        testType = 'Missing Body Test';
      } else if (testName.includes('Invalid Path Parameters')) {
        testType = 'Invalid Path Test';
      } else if (testName.includes('Invalid Query Parameters')) {
        testType = 'Invalid Query Test';
      } else if (testName.includes('Missing Query Parameters')) {
        testType = 'Missing Query Test';
      } else if (testName.includes('Wrong Content-Type')) {
        testType = 'Wrong Content-Type Test';
      } else if (testName.includes('Malformed JSON')) {
        testType = 'Malformed JSON Test';
      } else if (testName.includes('Oversized Payload')) {
        testType = 'Oversized Payload Test';
      } else if (testName.includes('SQL Injection')) {
        testType = 'SQL Injection Test';
      } else if (testName.includes('Special Characters')) {
        testType = 'Special Characters Test';
      } else if (testName.includes('Empty Values')) {
        testType = 'Empty Values Test';
      }

      // Get the expected keys for this test type
      const expectedKeys = TEST_CASE_EXPECTED_KEYS[testType] || [];
      
      // Build the expected results HTML
      let expectedResultsHtml = '';
      expectedKeys.forEach(key => {
        const results = EXPECTED_RESULTS_MAP[key] || [];
        results.forEach(result => {
          expectedResultsHtml += `
            <div class="expected-response-item">
              <div class="expected-response-label">${result.icon} ${result.label}:</div>
              <div class="expected-response-value">Expected: ${result.expected}</div>
            </div>
          `;
        });
      });

      return expectedResultsHtml;
    }

    // Multi cURL input validation
    multiCurlInput.addEventListener("input", () => {
      const trimmed = multiCurlInput.value.trim();
      executeMultiBtn.disabled = !(trimmed && trimmed.includes("curl"));
    });

    function highlightBlock(blockLines) {
      let blockColor = "red";
      if (blockLines.some(l => l.includes("Passed"))) {
        blockColor = "green";
      } else if (blockLines.some(l => l.includes("Test Case Skipped"))) {
        blockColor = "orange";
      }

      return blockLines.map((line, idx) => {
        let highlighted = line;

        highlighted = highlighted.replace(/API Status Code:\s*(\d+)/g, (match, code) => {
          return `API Status Code: <span style="color:${blockColor}; font-weight:bold">${code}</span>`;
        });

        highlighted = highlighted
          .replace(/\bPassed\b/g, `<span style="color:green; font-weight:bold">Passed</span>`)
          .replace(/\bFailed\b/g, `<span style="color:red; font-weight:bold">Failed</span>`)
          .replace(/Test Case Skipped/g, `<span style="color:orange; font-weight:bold">Test Case Skipped</span>`);

        if (idx === 0 && line.startsWith("=== Running")) {
          let statusText = "";
          if (blockColor === "green") statusText = " ‚úÖ Passed";
          else if (blockColor === "red") statusText = " ‚ùå Failed";
          else if (blockColor === "orange") statusText = " ‚ö†Ô∏è Skipped";

          highlighted += ` <span style="color:${blockColor}; font-weight:bold">${statusText}</span>`;
        }

        return highlighted;
      });
    }

    function appendLog(message) {
      // Check if this is a multi-API result (contains "=== API" patterns)
      if (message.includes("=== API") && message.includes("Total APIs:")) {
        displayGridResults(message);
        return;
      }
      
      // For single API results, use improved format with request/response boxes
      const lines = message.split("\n");
      let currentBlock = [];

      function flushBlock() {
        if (currentBlock.length === 0) return;
        const highlightedLines = highlightBlock(currentBlock);
        const testName = highlightedLines[0];
        const details = highlightedLines.slice(1);
        
        // Parse request and response details
        const { requestDetails, responseDetails } = parseRequestResponseDetails(details);

        const header = document.createElement("div");
        header.className = "section-header";

        const arrow = document.createElement("span");
        arrow.className = "arrow collapsed";
        arrow.textContent = "‚ñ∂";

        const text = document.createElement("span");
        text.innerHTML = testName;

        const body = document.createElement("div");
        body.className = "section-body";

        header.addEventListener("click", () => {
          const expanded = body.style.display === "block";
          body.style.display = expanded ? "none" : "block";
          arrow.textContent = expanded ? "‚ñ∂" : "‚ñº";
        });

        header.appendChild(arrow);
        header.appendChild(text);
        logs.appendChild(header);
        logs.appendChild(body);

        // Add request and response detail boxes
        if (requestDetails) {
          const requestBox = document.createElement("div");
          requestBox.className = "request-details";
          requestBox.innerHTML = `
            <div class="detail-box-header">
              üì§ Request Details
            </div>
            <div class="detail-box-content">${requestDetails.trim()}</div>
          `;
          body.appendChild(requestBox);
        }

        if (responseDetails) {
          const responseBox = document.createElement("div");
          responseBox.className = "response-details";
          responseBox.innerHTML = `
            <div class="detail-box-header">
              üì• Response Details
              ${responseDetails.statusCode ? `<span class="status-code ${getStatusCodeClass(responseDetails.statusCode)}">${responseDetails.statusCode}</span>` : ''}
            </div>
            <div class="detail-box-content">${responseDetails.content.trim()}</div>
          `;
          body.appendChild(responseBox);
        }

         // Add Expected Response field - show only relevant expectations for this test
         const expectedResponseBox = document.createElement("div");
         expectedResponseBox.className = "expected-response";
         const relevantExpectedResults = getRelevantExpectedResults(testName);
         expectedResponseBox.innerHTML = `
           <div class="expected-response-header">
             üéØ Expected Results
           </div>
           <div class="expected-response-content">
             ${relevantExpectedResults || '<div class="expected-response-item"><div class="expected-response-value">No specific expectations defined for this test.</div></div>'}
           </div>
         `;
         body.appendChild(expectedResponseBox);

        // For skipped tests or tests without structured details, show raw content
        const hasStructuredDetails = requestDetails || responseDetails;
        const rawContent = details.join('\n').trim();
        if (!hasStructuredDetails && rawContent) {
          const testContentBox = document.createElement("div");
          testContentBox.className = "test-content";
          const contentLength = rawContent.length > 1000 ? `<span class="content-length">(${rawContent.length} characters)</span>` : '';
          testContentBox.innerHTML = `
            <div class="detail-box-header">
              üìã Test Details
              ${contentLength}
            </div>
            <div class="detail-box-content">${rawContent}</div>
          `;
          body.appendChild(testContentBox);
        }

        currentBlock = [];
      }

      lines.forEach(line => {
        if (line.startsWith("=== Running")) {
          flushBlock();
          currentBlock.push(line);
        } else {
          currentBlock.push(line);
        }
      });

      flushBlock();
      logs.scrollTop = logs.scrollHeight;
    }
    
    function displayGridResults(message) {
      logs.innerHTML = "";
      
      // Create results grid container
      const gridContainer = document.createElement("div");
      gridContainer.className = "results-grid";
      
      // Parse the message to extract API results
      const apiSections = message.split(/=== API \d+:/);
      const summaryMatch = message.match(/Total APIs: (\d+).*Total Tests: (\d+).*Passed: (\d+).*Failed: (\d+)/);
      
      if (summaryMatch) {
        const totalAPIs = parseInt(summaryMatch[1]);
        const totalTests = parseInt(summaryMatch[2]);
        const passedTests = parseInt(summaryMatch[3]);
        const failedTests = parseInt(summaryMatch[4]);
        
        // Create summary card
        const summaryCard = createSummaryCard(totalAPIs, totalTests, passedTests, failedTests);
        gridContainer.appendChild(summaryCard);
      }
      
      // Process each API section
      for (let i = 1; i < apiSections.length; i++) {
        const apiSection = apiSections[i];
        const apiCard = createAPICard(i, apiSection);
        if (apiCard) {
          gridContainer.appendChild(apiCard);
        }
      }
      
      logs.appendChild(gridContainer);
    }
    
    function createSummaryCard(totalAPIs, totalTests, passedTests, failedTests) {
      const card = document.createElement("div");
      card.className = "result-card info";
      
      const skippedTests = totalTests - passedTests - failedTests;
      
      card.innerHTML = `
        <div class="card-header">
          <h3 class="card-title">
            üìä Execution Summary
          </h3>
          <span class="status-badge ${passedTests === totalTests ? 'success' : failedTests > 0 ? 'error' : 'warning'}">
            ${passedTests}/${totalTests} Tests
          </span>
        </div>
        <div class="card-body">
          <div class="test-summary">
            <div class="summary-item">
              <h4>${totalAPIs}</h4>
              <p>APIs Tested</p>
            </div>
            <div class="summary-item passed">
              <h4>${passedTests}</h4>
              <p>Passed</p>
            </div>
            <div class="summary-item failed">
              <h4>${failedTests}</h4>
              <p>Failed</p>
            </div>
            ${skippedTests > 0 ? `
            <div class="summary-item skipped">
              <h4>${skippedTests}</h4>
              <p>Skipped</p>
            </div>
            ` : ''}
          </div>
        </div>
      `;
      
      return card;
    }
    
    function createAPICard(apiNumber, apiSection) {
      if (!apiSection.trim()) return null;
      
      const lines = apiSection.split('\n');
      const apiName = extractAPINameFromSection(apiSection);
      
      // Count test results
      const passedCount = (apiSection.match(/Passed/g) || []).length;
      const failedCount = (apiSection.match(/Failed/g) || []).length;
      const skippedCount = (apiSection.match(/Test Case Skipped/g) || []).length;
      
      const totalTests = passedCount + failedCount + skippedCount;
      
      // Determine card status
      let cardStatus = 'info';
      let statusBadge = 'info';
      
      if (passedCount === totalTests && totalTests > 0) {
        cardStatus = 'success';
        statusBadge = 'success';
      } else if (failedCount > 0) {
        cardStatus = 'error';
        statusBadge = 'error';
      } else if (skippedCount > 0) {
        cardStatus = 'warning';
        statusBadge = 'warning';
      }
      
      const card = document.createElement("div");
      card.className = `result-card ${cardStatus}`;
      
      // Extract test details
      const testDetails = extractTestDetails(apiSection);
      
      card.innerHTML = `
        <div class="card-header">
          <h3 class="card-title">
            üîó ${apiName}
          </h3>
          <span class="status-badge ${statusBadge}">
            ${passedCount}/${totalTests} Passed
          </span>
        </div>
        <div class="card-body">
          <div class="test-summary">
            <div class="summary-item passed">
              <h4>${passedCount}</h4>
              <p>Passed</p>
            </div>
            <div class="summary-item failed">
              <h4>${failedCount}</h4>
              <p>Failed</p>
            </div>
            <div class="summary-item skipped">
              <h4>${skippedCount}</h4>
              <p>Skipped</p>
            </div>
          </div>
          
          <div class="test-details">
            <h5>Test Results</h5>
            <div class="test-list">
              ${testDetails.map(test => `
                <span class="test-item ${test.status}">
                  ${getStatusIcon(test.status)} ${test.name}
                </span>
              `).join('')}
            </div>
          </div>
          
          <button class="expand-btn" onclick="toggleDetails(this)">
            üìã View Detailed Results
          </button>
          
          <div class="detailed-results">
            ${formatDetailedResults(apiSection)}
          </div>
        </div>
      `;
      
      return card;
    }
    
    function extractAPINameFromSection(apiSection) {
      // Look for URL patterns in the section
      const urlMatch = apiSection.match(/https?:\/\/[^\s]+/);
      if (urlMatch) {
        const url = urlMatch[0];
        return extractCleanAPIName(url);
      }
      
      // Fallback to first line extraction
      const lines = apiSection.split('\n');
      const firstLine = lines[0];
      const match = firstLine.match(/API \d+: (.+)/);
      return match ? match[1] : 'Unknown API';
    }
    
    function extractCleanAPIName(url) {
      try {
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        
        // Remove common base paths and extract meaningful endpoint
        let cleanPath = pathname
          .replace(/^\/api\/v?\d*/, '') // Remove /api, /api/v1, etc.
          .replace(/^\/user-service/, '') // Remove service prefixes
          .replace(/^\/asset/, '') // Remove common prefixes
          .replace(/^\/onboarding/, '')
          .replace(/^\//, '') // Remove leading slash
          .replace(/\/$/, ''); // Remove trailing slash
        
        // If path is empty or too short, use the last meaningful part
        if (!cleanPath || cleanPath.length < 3) {
          const pathParts = pathname.split('/').filter(part => part && part !== 'api' && !part.match(/^v\d+$/));
          cleanPath = pathParts[pathParts.length - 1] || 'endpoint';
        }
        
        // Capitalize and format
        return cleanPath
          .split('/')
          .map(part => part.charAt(0).toUpperCase() + part.slice(1))
          .join(' ')
          .replace(/-/g, ' ')
          .replace(/_/g, ' ');
      } catch (e) {
        return 'API Endpoint';
      }
    }
    
    function formatDetailedResults(apiSection) {
      const lines = apiSection.split('\n');
      const testBlocks = [];
      let currentBlock = [];
      
      lines.forEach(line => {
        if (line.startsWith('=== Running')) {
          if (currentBlock.length > 0) {
            testBlocks.push(currentBlock);
          }
          currentBlock = [line];
        } else if (line.trim()) {
          currentBlock.push(line);
        }
      });
      
      if (currentBlock.length > 0) {
        testBlocks.push(currentBlock);
      }
      
      return testBlocks.map(block => {
        const testName = block[0].replace('=== Running ', '').replace(' ===', '');
        const status = getTestStatus(block);
        const details = block.slice(1).filter(line => line.trim());
        
        // Parse request and response details
        const { requestDetails, responseDetails } = parseRequestResponseDetails(details);
        
        // For skipped tests, show raw content if no structured details
        const hasStructuredDetails = requestDetails || responseDetails;
        const rawContent = details.join('\n').trim();
        
        return `
          <div class="test-block">
            <div class="test-block-header">
              <h6>${getStatusIcon(status)} ${testName}</h6>
              <span class="test-status ${status}">${status.toUpperCase()}</span>
            </div>
            <div class="test-block-details">
              ${requestDetails ? `
                <div class="request-details">
                  <div class="detail-box-header">
                    üì§ Request Details
                  </div>
                  <div class="detail-box-content">${requestDetails.trim()}</div>
                </div>
              ` : ''}
              ${responseDetails ? `
                <div class="response-details">
                  <div class="detail-box-header">
                    üì• Response Details
                    ${responseDetails.statusCode ? `<span class="status-code ${getStatusCodeClass(responseDetails.statusCode)}">${responseDetails.statusCode}</span>` : ''}
                  </div>
                  <div class="detail-box-content">${responseDetails.content.trim()}</div>
                </div>
              ` : ''}
               <div class="expected-response">
                 <div class="expected-response-header">
                   üéØ Expected Results
                 </div>
                 <div class="expected-response-content">
                   ${getRelevantExpectedResults(testName) || '<div class="expected-response-item"><div class="expected-response-value">No specific expectations defined for this test.</div></div>'}
                 </div>
               </div>
              ${!hasStructuredDetails && rawContent ? `
                <div class="test-content">
                  <div class="detail-box-header">
                    üìã Test Details
                    ${rawContent.length > 1000 ? `<span class="content-length">(${rawContent.length} characters)</span>` : ''}
                  </div>
                  <div class="detail-box-content">${rawContent}</div>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      }).join('');
    }
    
    function getTestStatus(block) {
      const blockText = block.join(' ').toLowerCase();
      if (blockText.includes('passed')) return 'passed';
      if (blockText.includes('failed') || blockText.includes('error') || 
          blockText.includes('exception') || blockText.includes('timeout')) return 'failed';
      if (blockText.includes('skipped') || blockText.includes('skip')) return 'skipped';
      return 'running';
    }
    
    function extractTestDetails(apiSection) {
      const tests = [];
      const lines = apiSection.split('\n');
      
      lines.forEach((line, index) => {
        if (line.includes('=== Running')) {
          const testName = line.replace('=== Running ', '').replace(' ===', '');
          let status = 'running';
          
          // Look for the test result in the entire section, not just next 10 lines
          // Find the next "=== Running" or end of section to determine scope
          let endIndex = lines.length;
          for (let i = index + 1; i < lines.length; i++) {
            if (lines[i].includes('=== Running')) {
              endIndex = i;
              break;
            }
          }
          
          // Check all lines in this test's scope for status indicators
          const testLines = lines.slice(index, endIndex);
          const testText = testLines.join(' ');
          
          // More comprehensive status detection with case-insensitive matching
          const lowerText = testText.toLowerCase();
          if (lowerText.includes('passed')) {
            status = 'passed';
          } else if (lowerText.includes('failed') || lowerText.includes('error') || 
                     lowerText.includes('exception') || lowerText.includes('timeout')) {
            status = 'failed';
          } else if (lowerText.includes('skipped') || lowerText.includes('skip')) {
            status = 'skipped';
          }
          
          // Debug logging to help identify status detection issues
          console.log('Test status detection:', {
            testName: testName,
            status: status,
            hasPassed: lowerText.includes('passed'),
            hasFailed: lowerText.includes('failed') || lowerText.includes('error'),
            hasSkipped: lowerText.includes('skipped') || lowerText.includes('skip'),
            textSample: testText.substring(0, 300)
          });
          
          tests.push({
            name: testName,
            status: status
          });
        }
      });
      
      return tests;
    }
    
    function getStatusIcon(status) {
      switch(status) {
        case 'passed': return '‚úÖ';
        case 'failed': return '‚ùå';
        case 'skipped': return '‚ö†Ô∏è';
        case 'running': return 'üîÑ';
        default: return 'üìã';
      }
    }

    function parseRequestResponseDetails(details) {
      let requestDetails = '';
      let responseDetails = { content: '', statusCode: null };
      let currentSection = '';
      
      details.forEach(line => {
        // Request details
        if (line.includes('Request Headers') || line.includes('Request Method') || 
            line.includes('Request URL') || line.includes('Request Body') || 
            line.includes('Request Path Param') || line.includes('Request Query Params')) {
          currentSection = 'request';
          requestDetails += line + '\n';
        }
        // Response details
        else if (line.includes('API Status Code') || line.includes('Response Headers') || 
                 line.includes('Response Body') || line.includes('Response Time') ||
                 line.includes('Response URL') || line.includes('Response Method')) {
          currentSection = 'response';
          responseDetails.content += line + '\n';
          
          // Extract status code
          const statusMatch = line.match(/API Status Code:\s*(\d+)/);
          if (statusMatch) {
            responseDetails.statusCode = statusMatch[1];
          }
        }
        // Continue current section
        else if (line.trim() && currentSection === 'request') {
          requestDetails += line + '\n';
        }
        else if (line.trim() && currentSection === 'response') {
          responseDetails.content += line + '\n';
        }
      });
      
      return {
        requestDetails: requestDetails.trim() || null,
        responseDetails: responseDetails.content.trim() ? {
          content: responseDetails.content.trim(),
          statusCode: responseDetails.statusCode
        } : null
      };
    }

    function getStatusCodeClass(statusCode) {
      const code = parseInt(statusCode);
      if (code >= 200 && code < 300) return 'success';
      if (code >= 400 && code < 500) return 'error';
      if (code >= 500) return 'error';
      if (code >= 300 && code < 400) return 'warning';
      return 'info';
    }
    
    function toggleDetails(button) {
      const detailedResults = button.nextElementSibling;
      const isExpanded = detailedResults.classList.contains('show');
      
      if (isExpanded) {
        detailedResults.classList.remove('show');
        button.textContent = 'üìã View Detailed Results';
      } else {
        detailedResults.classList.add('show');
        button.textContent = 'üìã Hide Detailed Results';
      }
    }

    // Multi cURL execution
    executeMultiBtn.addEventListener("click", async () => {
      const curlCommands = multiCurlInput.value.trim();

      if (!curlCommands.includes("curl")) {
        appendLog("‚ùå Invalid format. Must contain cURL commands.");
        return;
      }

      executeMultiBtn.disabled = true;
      loader.style.display = "block";
      logs.innerHTML = "";

      const execStart = document.createElement("div");
      execStart.style.fontWeight = "bold";
      execStart.style.marginBottom = "10px";
      execStart.textContent = "üöÄ Multiple APIs Execution Starts...";
      logs.appendChild(execStart);

      const curlCmdBlock = document.createElement("div");
      curlCmdBlock.className = "curl-preview";
      curlCmdBlock.textContent = curlCommands;
      logs.appendChild(curlCmdBlock);

      try {
        const response = await fetch("/api/execute-multi-curl", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ curlCommands: [curlCommands] })
        });

        // Check if response is ok (status 200-299)
        if (!response.ok) {
          const errorText = await response.text();
          appendLog("‚ùå Server Error: " + response.status + " - " + errorText);
          
          const execEnd = document.createElement("div");
          execEnd.style.fontWeight = "bold";
          execEnd.style.marginTop = "10px";
          execEnd.style.color = "red";
          execEnd.textContent = "‚ùå Multiple APIs Execution Failed";
          logs.appendChild(execEnd);
          return;
        }

        const text = await response.text();
        appendLog(text);

        const execEnd = document.createElement("div");
        execEnd.style.fontWeight = "bold";
        execEnd.style.marginTop = "10px";
        execEnd.textContent = "üèÅ Multiple APIs Execution Finished";
        logs.appendChild(execEnd);

      } catch (err) {
        appendLog("‚ùå Network Error: " + err.message);
        
        const execEnd = document.createElement("div");
        execEnd.style.fontWeight = "bold";
        execEnd.style.marginTop = "10px";
        execEnd.style.color = "red";
        execEnd.textContent = "‚ùå Multiple APIs Execution Failed";
        logs.appendChild(execEnd);
      } finally {
        loader.style.display = "none";
        const trimmed = multiCurlInput.value.trim();
        executeMultiBtn.disabled = !(trimmed && trimmed.includes("curl"));
      }
    });
</script>

</body>
</html>
